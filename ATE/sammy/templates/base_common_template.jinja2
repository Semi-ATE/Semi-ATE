# -*- coding: utf-8 -*-
"""
{{ definition['hardware'] }}/FT/common.py


Don't edit this file. It is bound to be regenerated if the project
configuration changes. Any manual edits will be lost in that case.
"""
import json
import os
import sys
import pathlib
import traceback
from ATE.Tester.TES.apps.testApp.sequencers.Sequencer import Sequencer
from ATE.Tester.TES.apps.testApp.sequencers.SequencerBase import SequencerBase
from ATE.Tester.TES.apps.testApp.sequencers.SequencerBase import SequencerBase
from ATE.Tester.TES.apps.testApp.auto_script.AutoScriptBase import AutoScriptBase
from ATE.Tester.TES.apps.testApp.sequencers import Harness
from ATE.Tester.TES.apps.testApp.stages_sequence_generator.stages_sequence_generator import StagesSequenceGenerator
from ATE.Tester.TES.apps.testApp.sequencers.mqtt.MqttConnection import MqttConnection
from ATE.semiateplugins.pluginmanager import get_plugin_manager
from ATE.common.logger import Logger, LogLevel


class Context:
    def __init__(
        self,
        source: str,
        params: dict,
        sequencer: SequencerBase,
        auto_script: AutoScriptBase,
        execution_strategy: StagesSequenceGenerator,
        mqtt: MqttConnection,
        harness_strategy: Harness):
        {#
        # ToDo: Refactor generation of sequencer and harness to make sure, that:
        #       * An exception due to the bintable missing or creation of the bin strategy failing will get logged
        #       * An exception during creation of the harness will at least get logged to file
        #}
        self.harness = Sequencer(sequencer, params, execution_strategy, mqtt, harness_strategy)
        self.logger = Logger(source, self.harness)

        # Logging is available @ Info Level during startup of the
        # sequencer. After the C'tor has finished, we automatically
        # revert to "Warrning"
        self.logger.set_logger_level(LogLevel.Info)
        try:
            self.auto_script = auto_script
            self.auto_script.set_logger(self.logger)
            self.auto_script.set_context(self)
            self.harness.set_after_terminate_callback(lambda: self.auto_script.after_terminate_teardown())
            self.harness.set_logger(self.logger)
            sequencer.set_logger(self.logger)
            sequencer.set_auto_script(self.auto_script)

            # Tester
            testers = get_plugin_manager().hook.get_tester(tester_name="{{definition["tester"]}}")
            assert len(testers) < 2, "The testertype {{definition["tester"]}} maps to multiple testers. Check installed plugins."
            assert len(testers) == 1, "The testertype {{definition["tester"]}} is not available or installed on this machine."
            self.tester_instance = testers[0]
            sequencer.set_tester_instance(self.tester_instance)

            {% for actuator in definition['Actuator'][definition['active_base']] %}
            from ATE.Tester.TES.apps.testApp.actuators.{{actuator}}.{{actuator}} import {{actuator}}Proxy
            self.{{actuator}}_instance = {{actuator}}Proxy()
            self.{{actuator}}_instance.set_mqtt_client(self.harness)
            {% endfor %}

            self.setup_plugins(self.logger)
        except Exception as e:
            exc = traceback.format_exc()
            self.logger.log_message(LogLevel.Error, exc)
            # Exceptions in this stage are per definition fatal
            sys.exit()

        self.logger.set_logger_level(LogLevel.Warning)

    def setup_plugins(self, logger: Logger):
        instrument_dict = {}
        {% for instrument in definition['Instruments'] %}
        instruments = get_plugin_manager().hook.get_instrument(instrument_name="{{instrument}}", logger=logger)
        assert len(instruments) < 2, "The instrumenttype {{instrument}} maps to multiple instruments. Check installed plugins."
        assert len(instruments) == 1, "The instrumenttype {{instrument}} is not available or installed on this machine."
        self.{{definition['InstrumentNames'][instrument]}}_instance = instruments[0]
        instrument_dict['{{instrument}}'] = self.{{definition['InstrumentNames'][instrument]}}_instance
        {% endfor %}

        apply_configuration(instrument_dict)

        self.gp_dict = {}
        {% for gpfunction in definition['GPFunctions'] %}
        gpfuncs = get_plugin_manager().hook.get_general_purpose_function(func_name="{{gpfunction}}", logger=logger)
        assert len(gpfuncs) < 2, "The functiontype {{gpfunction}} maps to multiple functions. Check installed plugins."
        assert len(gpfuncs) == 1, "The functiontype {{gpfunction}} is not available or installed on this machine."
        self.{{definition['GPFunctionNames'][gpfunction]}}_instance = gpfuncs[0]
        self.gp_dict['{{gpfunction}}'] = self.{{definition['GPFunctionNames'][gpfunction]}}_instance
        {% endfor %}

        apply_configuration(self.gp_dict)

    def get_logger(self) -> Logger:
        return self.logger

    def after_exception_callback(self, source: str, error: Exception):
        self.auto_script.after_exception_teardown(source, error)

    def after_cycle_callback(self):
        self.auto_script.after_cycle_teardown()


def apply_configuration(feature_dict):
    for name, instance in feature_dict.items():
        config_file_path = pathlib.Path(os.path.join(pathlib.Path(__file__).parent.absolute(), "..", f"{name}.json"))
        if os.path.exists(config_file_path):
            with open(config_file_path) as reader:
                instance.apply_configuration(json.loads(reader.read()))


def make_context(
    source: str,
    params: dict,
    sequencer: SequencerBase,
    auto_script: AutoScriptBase,
    execution_strategy: StagesSequenceGenerator,
    mqtt: MqttConnection,
    harness_strategy: Harness
    ) -> Context:
    return Context(source, params, sequencer, auto_script, execution_strategy, mqtt, harness_strategy)
